variables:
  AWS_DEFAULT_REGION: us-east-1
  AWS_ACCOUNT_ID: "058264373862"
  ECR_REPO_URL: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${CI_PROJECT_NAME}-${CI_ENVIRONMENT_NAME}
  DOCKER_IMAGE: ${ECR_REPO_URL}:${CI_COMMIT_SHORT_SHA}
  TF_ROOT: ${CI_PROJECT_DIR}
  AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
  AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
  ENVIRONMENT:
    value: dev
    options:
      - dev
      - staging
      - prod
    description: The environment to deploy

# Reusable workflow rules
.rules-feature:
  rules:
    - if: $CI_COMMIT_BRANCH =~ /-[A-Z]{2,}-[0-9]+/  # Matches feature branches like "feature-JIRA-123"

.rules-release:
  rules:
    - if: $CI_COMMIT_BRANCH =~ /^release-/  # Matches branches starting with "release-"

.rules-merge-to-release:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME =~ /^release-/

stages:
  - build
  - validate
  - plan
  - apply

# Build jobs for different scenarios
build-feature:
  stage: build
  image: 
    name: amazon/aws-cli:latest
    entrypoint: [""]
  services:
    - docker:dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - aws configure set aws_access_key_id ${AWS_ACCESS_KEY_ID}
    - aws configure set aws_secret_access_key ${AWS_SECRET_ACCESS_KEY}
    - aws configure set region ${AWS_DEFAULT_REGION}
    - amazon-linux-extras install docker
    - aws --version
    - docker --version
    - aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URL}
  script:
    - cd modules/poc-api/src
    - docker build -t ${DOCKER_IMAGE} .
    - docker push ${DOCKER_IMAGE}
    - docker tag ${DOCKER_IMAGE} ${ECR_REPO_URL}:latest
    - docker push ${ECR_REPO_URL}:latest
  extends: .rules-feature

build-release:
  stage: build
  image: 
    name: amazon/aws-cli:latest
    entrypoint: [""]
  services:
    - docker:dind
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - aws configure set aws_access_key_id ${AWS_ACCESS_KEY_ID}
    - aws configure set aws_secret_access_key ${AWS_SECRET_ACCESS_KEY}
    - aws configure set region ${AWS_DEFAULT_REGION}
    - amazon-linux-extras install docker
    - aws --version
    - docker --version
    - aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_URL}
  script:
    - cd modules/poc-api/src
    - docker build -t ${DOCKER_IMAGE} .
    - docker push ${DOCKER_IMAGE}
    - docker tag ${DOCKER_IMAGE} ${ECR_REPO_URL}:latest
    - docker push ${ECR_REPO_URL}:latest
  extends: .rules-release

.terraform:
  image:
    name: alpine:3.19
    entrypoint: [""]
  variables:
    TERRAFORM_VERSION: "1.6.0"
    AWS_ACCESS_KEY_ID: ${TF_AWS_ACCESS_KEY_ID}
    AWS_SECRET_ACCESS_KEY: ${TF_AWS_SECRET_ACCESS_KEY}
    AWS_DEFAULT_REGION: ${AWS_DEFAULT_REGION}
    AWS_ROLE_ARN: "arn:aws:iam::${AWS_ACCOUNT_ID}:role/terraform-gitlab-role"
    AWS_SESSION_NAME: "GitLabCI-${CI_PROJECT_NAME}-${CI_PIPELINE_ID}"
  cache:
    key: terraform
    paths:
      - ${TF_ROOT}/.terraform
  before_script:
    - apk add --no-cache curl unzip python3 py3-pip jq
    - pip3 install --no-cache-dir awscli
    - curl -LO https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - unzip terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - mv terraform /usr/local/bin/
    - rm terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    - aws configure set aws_access_key_id ${TF_AWS_ACCESS_KEY_ID}
    - aws configure set aws_secret_access_key ${TF_AWS_SECRET_ACCESS_KEY}
    - aws configure set region ${AWS_DEFAULT_REGION}
    - |
      CREDENTIALS=$(aws sts assume-role \
        --role-arn "${AWS_ROLE_ARN}" \
        --role-session-name "${AWS_SESSION_NAME}" \
        --duration-seconds 3600)
    - export AWS_ACCESS_KEY_ID=$(echo ${CREDENTIALS} | jq -r '.Credentials.AccessKeyId')
    - export AWS_SECRET_ACCESS_KEY=$(echo ${CREDENTIALS} | jq -r '.Credentials.SecretAccessKey')
    - export AWS_SESSION_TOKEN=$(echo ${CREDENTIALS} | jq -r '.Credentials.SessionToken')
    - cd ${TF_ROOT}

terraform-validate:
  extends: .terraform
  stage: validate
  script:
    - terraform init -backend=false
    - terraform validate
  rules:
    - if: $CI_COMMIT_BRANCH
      when: always

terraform-plan:
  extends: .terraform
  stage: plan
  script:
    - terraform init -backend-config=backends/${ENVIRONMENT}.hcl
    - terraform plan -var-file=tfvars/${ENVIRONMENT}.tfvars -out=plan.tfplan
  artifacts:
    paths:
      - plan.tfplan
    expire_in: 1 week
  rules:
    - if: $ENVIRONMENT
      when: manual
  needs:
    - terraform-validate

terraform-apply:
  extends: .terraform
  stage: apply
  script:
    - terraform init -backend-config=backends/${ENVIRONMENT}.hcl
    - terraform apply -auto-approve plan.tfplan
  rules:
    - if: $ENVIRONMENT
      when: manual
  dependencies:
    - terraform-plan
  needs:
    - terraform-plan